Main stable release blockers
----------------------------

* decide what to do about reader for backslash escaping newlines

* maybe unix pipeline should stringify 0-i as -i rather than having the reader change the meaning of #\-

* are rash macros a (begin ...) or a (let () ...)?

* alternate reader where bare things on the top level are assumed to be normal racket UNLESS there is an explicit start pipe.  This would give an option to have a repl *almost* the same as the default racket repl, except with an easy escape into shell-world.

* $_ implicit argument on pipelines
** for unix ones, detect it, use compound member to turn the input into an empty port and use $_ as a shell argument.  This may require rethinking the eager evaluation of arg list members...

* unix pipeline member arguments #:e>, #:as, #:how-to-determine-success etc
** success determination should allow a predicate on the return value OR a list of good statuses
** some sort of alias-like thing to set an alternative default for success, so eg. grep can use this alias-like thing to save writing #:success '(0 1)

* unix pipeline operator that has a higher level alias functionality like the old rash had
** actually, there should probably be both a unixy operator AND an object operator that recognize aliases - these aliases can basically just make the operator resolution recur.  So you could have =u= grep foo, where grep is an alias to =u= #:success (list 1) "grep" foo.  You could have this alias checking and recursive lookup on any pipeline type, so maybe several of them should have it.  But then again, if an alias just causes a recursive operator resolution... what is the difference between having an alias and having another operator?

* pipeline that acts as an object pipe unless the function part is undefined as syntax, in which case it acts as a unixy pipe instead.

* unix pipeline operator that does globbing

* optional kw-args for rash macros that affect read tables, macros to define rash macros and rash-module-begin with different defaults for all options including read table options

* some level of macros above pipelines - eg for define forms, maybe loops, etc.
** examples of macros I want
*** definition form -- {def files find . -type f |> sort}, {def (get-files d) find $d -type f |> sort}
*** lambda form -- {lam (pat file) grep pat file | wc -l |> string-trim |> string->number}
**** equivalent to (λ (pat file) (rash «grep pat file | wc -l |> ...»))
**** lambda form would be very useful for small embedding contexts
*** a lot of people I talked to want a loop form...
*** if form... again I could take it or leave it

* I can probably avoid the hash for default-starter by using 3d syntax in the stx-parameterize.  Is that better?


* a version of pipeline running/rash macros that doesn't have all the overhead (maybe one that doesn't allow unix-segments)
** maybe it's not terribly important, because it would be doing mostly the same thing as the threading macro, but it would be more flexible.
** =object-pipe= should have a keyword argument that sets whether it auto-converts ports, and the default is a syntax parameter that the efficient vs convenient rash macros can set accordingly.  Also, this allows the one-off occasions when you do want to do the opposite, without requiring a different =basic-object-pipe=
** obj-pipeline-spec, unix-pipeline-spec, and composite-pipeline-spec should be syntax parameters that are also set by the outside macro to be what they ought to be
** each level of pipeline operator unwrapping should check whether it got another pipeline operator or if it got a spec definition form, which will kill any runtime errors of not getting specs
*** BUT this would mean you couldn't wrap the struct forms, eg. (let ([foo aoeu]) (obj-spec (λ (arg) (foo arg foo)))) -- so is this a good idea?
*** Maybe the efficient version requires no wrapping, but the convenient one allows wrapping.

* obj-pipeline-members in same or different thread
** I put them in separate threads because it seemed like a good idea at the time for swapping bg/fg stuff.  But I also had a manager thread for the same purpose.  I don't need both.
** since the manager thread is already a separate thread, the others probably shouldn't be in further separated threads.
** BUT things like cd that change parameters need to be in the original thread - not even in the manager thread.
** but to be able to have object pipelines switch between being in the foreground and background I need them to be in a thread.
** I either need to not have a manager thread, or I need a level of macros above pipelines to allow something like `cd` to set the value of parameters in the main thread.

* maybe pipeline starters used as normal macros should work like (rash «starter-here arg ...»)
** how would this interact with having two different versions - the wrapped convenient backgroundable version vs the non-bg-able non-wrapped version?
*** this definitely would require more firm defaults, because you wouldn't be wrapping it in anything that could set defaults.
*** maybe there are forms to change the defaults (IE syntax-parameterizing) that are available just as s-expressions to wrap these with.
**** Maybe starter-operators have extra properties that say what they want the defaults to be, set by define-pipeline-operator?  Then every starter pipe is also a rash macro... (without a special reader)
*** maybe the fast one is the default, and only certain macros bother with the wrapped way?
** if an explicit pipe were always required, this would just mean than newlines act as parens, but allowing implicit pipes is more like newlines are parens but there is an implicit #%rash-line-macro there.  Plus rash has a modified readtable to provide various conveniences.
*** a potentially useful idea is to have udelim string wrappers whose macro just changes the readtable inside.  This is similar to the option for that that already exists on list delimiters, but string delimiters won't have the issue of maybe not having that same delimiter inside.  You might just have a reader-changing macro that gives you the the rash reader.
**** maybe defaults are set (for wrapped/unwrapped rash, implicit pipe operator, etc) by an implicit #%rash-default-something-or-other macro.  Different rash modules could export different ones.  Problem: if you import two, you have this annoying collision.  This is probably not a good idea.

* have lexically scoped defaults for all pipeline options, similar to how the implicit starter operator works

* make it a syntax error to have a normal racket expression [IE starting a line with an open paren] have a pipeline later on the same line.  This will clear up any issues with having the first segment of a pipeline open with parens.

* review names -- pick good ones before doing any stable release

* add features to shell/pipeline from its todo to get to a stable release point

* document

* look through TODO comments



misc
----

* option-app -- needs better name (kw-check-app?), and should it be part of another package?  I think I want to use it in more packages...


About interactive shells
------------------------

* job control -- for an interactive shell, how should the shell capture references to the pipelines to do job control?

* discoverability
** the default prompt should help with discoverability -- maybe say the command to get help, look up docs, etc.  Something like «type HELP START» in LoE.
** how can interactive features be more discoverable than just being listed in the docs/tutorial?


Documentation
-------------

* API docs
* guide -- high level overview
** maybe split it into sections for people with different backgrounds - eg. racketeers vs people coming from bash who don't know racket.

