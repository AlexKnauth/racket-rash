* option for shared stderr string capture or individual ones.  Per unix-y section, at least.

* improve dollar-expansion -- eg. maybe don't always expand to a string, so I can use $funcname at the head of a unix pipe for unix-style functions in pipelines.

* mixed/pipeline pipeline-kill

* pipeline send signal?  eg. to send sighup when rash is killed so that some programs (eg nohup) can decide whether or not they should die.

* Better API for redirection settings in basic and mixed pipelines
** specifically, how to tell it truncate/append/error
** how to tell it you want stderr as a string-port or shared-string-port

* good API for setting defaults
** all default values should have syntax parameters that are either exposed as such or have a nice API for setting their values, and they should probably all live in one file in private/
*** specifically these include the defaults for in/out/err, the default pipeline starter, the default truncate/append/error behavior for out/err, default strict/permissive/lazy correctness, lazy-timeout,

* option for code to run in manager thread before running members in order to modify parameters - IE generalization of modifying env for all members.
** environment variable / generic thread environment mutation per-member as well

* process fd/temp-file redirects a la <() >() from bash
** Probably I want a flag struct for each.  The struct will contain a thunk that will evaluate to a file name (for <()) or will take a file name (for >(), the pipeline running mechanism will have to give it one).
** Unless it's actually backed by FD, the output process will have to finish before starting the input process, and pipeline waiting will have to wait for the sub-pipeline stuff as well...

* I should probably provide a standard wrapper for the run-pipeline macro that detects some AND and OR identifiers and splits into multiple run-pipeline macros that automatically turn on pipeline-object-return
** I should probably also change the option for returning the pipeline object to take an argument rather than being just a presence-only flag...

* inspecting pipeline segments with correct compound member handling

* add a set of symbols that the output-transformer can translate into common-case functions -- 'string, 'trim, 'lines, etc.

* look through TODO comments

* a version of pipeline-macro that doesn't have all the overhead (maybe one that doesn't allow unix-segments)
** maybe it's not terribly important, because it would be doing mostly the same thing as the threading macro, but it would be more flexible -- eg. =filter=, =for=, etc are nice, especially if they have short names.
** =object-pipe= should have a keyword argument that sets whether it auto-converts ports, and the default is a syntax parameter that the efficient vs convenient rash macros can set accordingly.  Also, this allows the one-off occasions when you do want to do the opposite, without requiring a different =basic-object-pipe=
** obj-pipeline-spec, unix-pipeline-spec, and composite-pipeline-spec should be syntax parameters that are also set by the outside macro, basically determining whether they produce runtime pipeline objects or if they desugar to the fast path that has no process or thread overhead.

* I want to have a macro to define a first class pipeline segment (IE a compound-pipeline-member, but one that is always a joint and not a starter).  Maybe a compound-pipeline-member can be called as a function, which takes one argument and shoves it into the pipeline?
** how will this interact with the trimmed-down version of the macro from above?


* Currently each object segment runs in its own thread, but maybe they should always run in the manager thread instead.  That way they can eg. mutate the environment, and that can be an easy way to implement whole-pipeline environment changes.  Also it will lower threading overhead.  However, it is the way it is currently so that the manager thread can (in some future day) catch a signal to suspend for job control.


less important TODO items, which may wait until version 2
---------------------------------------------------------

* bg issues
** what does it mean to run with stdin in the background unless I have job control?
** maybe the default input port should be allowed to be some function that determines what input it gets based on things like whether it's in the background or not?


* a custom exn type for unix pipeline failures?

* Pipeline suspend/resume -- Threads have pause/resume, Unix processes have sigstop/sigcont, but I'm not sure how to pause/suspend windows processes.  Maybe a Unix-only feature?  But this is a pretty standard shell feature for job control.

* job control -- for an interactive shell, how should the shell capture references to the pipelines to do job control?
** importantly, currently the repl is still the foreground process of the terminal when you press control c or control z, so it gets sigint or sigstop even when you have launched eg. vim
** I need to set a pipeline to all have the same process group ID that is different than the pgid of the host shell.  Right now I can either let them all keep the pgid of the shell or give each of them a different pgid.  Anything else would require changes to the subprocess API in the C code of Racket.
** I need to use `tcsetpgrp` to set the foreground process group on a terminal, to control which processes get sigint/sigstop signals from C-c and C-z.
** I maybe ought to do some signal handling setup of the subprocesses also, for sigtou, sigtin, and maybe I need to specially handle sighup and sigterm in the shell repl?
** When Racket gets SIGHUP the main thread generates exn:break:hang-up, and for SIGQUIT it generates exn:break:terminate.  So a handler around the main repl loop can propogate SIGHUP to any jobs (except disowned ones) and quit gracefully.

* bg pipeline disowning?
** This is really only reasonable for external-proccess-only pipelines, and I'm not sure how reasonable it is on Windows.

* ulimit and other resource limiting things for subprocesses and pipeline threads -- how can I go about doing that?

* initial input-port transformer to try to solve readline-port issues -- there doesn't seem to be any way to get the real stdin port from the readline port, so this is hopeless for the moment.
