Fully stable release blockers
-----------------------------

* process fd/temp-file redirects a la <() >() from bash

* a custom exn type for unix pipeline failures?

* inspecting pipeline segments with correct compound member handling

* bg issues
** what does it mean to run with stdin in the background unless I have job control?
** maybe the default input port should be allowed to be some function that determines what input it gets based on things like whether it's in the background or not?

* decide what to do with APIs that are bad, that I said are "mostly stable"...

* review names -- pick good ones before doing any stable release
** 'string-port for errors -- I don't like this one

* reorganize code -- everything in pipeline.rkt should just be exporting something defined in private/

* API - be sure it's conservative enough to change implementation details (eg. for spec creation)
* contracts - check old ones, make new ones
* document new stuff, fix old docs

* look through TODO comments


Other todo, maybe for version 2
-------------------------------

* Pipeline suspend/resume -- Threads have pause/resume, Unix processes have sigstop/sigcont, but I'm not sure how to pause/suspend windows processes.  Maybe a Unix-only feature?  But this is a pretty standard shell feature for job control.

* bg pipeline disowning?
    Disowning will probably only work for pipelines
    without any racket functions or filters in them.  But perhaps you should
    be able to mark a pipeline as disownable, which would start a new racket
    process which would run the pipeline?  It would have to be very restricted,
    because a pipeline could be using closures, which could not really be copied.
    It looks like bash and zsh can disown a backgrounded shell
    function and have it survive the shell exiting if that function was started
    in the background, which tells me that backgrounded bash/zsh functions are
    run in a subshell.  Presumably this means the process is forked, so that
    the subshell can still access all previously defined functions.  I feel
    like this could have many cases of subtle weirdness, so I'm not sure I
    want to follow that direction without something more explicit marking a
    clear boundary.  Also, fork() only works on Unix, and it would be nice if
    the shell worked on Windows too, so if I can reasonably avoid relying on
    fork, I should.

* initial input-port transformer to try to solve readline-port issues -- there doesn't seem to be any way to get the real stdin port from the readline port, so this is hopeless for the moment.