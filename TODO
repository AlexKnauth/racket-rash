Fully stable release blockers
-----------------------------

* option for shared stderr string capture or individual ones.  Per unix-y section, at least.

* environment variable augment/replace per-member

* option for code to run in manager thread before running members in order to modify parameters - IE generalization of modifying env for all members.

* process fd/temp-file redirects a la <() >() from bash

* inspecting pipeline segments with correct compound member handling

* reorganize code -- everything in pipeline.rkt should just be exporting something defined in private/

* add a set of symbols that the output-transformer can translate into common-case functions -- 'string, 'trim, 'lines, etc.

* decide what to do with APIs that are bad, that I said are "mostly stable"...

* review names -- pick good ones before doing any stable release
** *-pipeline-member-spec should be better -- eg. `object` instead of `obj`.
** 'string-port for errors -- I don't like this one

* look through TODO comments

* API - be sure it's conservative enough to change implementation details (eg. for spec creation)
* contracts - check old ones, make new ones
* document new stuff, fix old docs


less important TODO items, which may wait until version 2
---------------------------------------------------------

* bg issues
** what does it mean to run with stdin in the background unless I have job control?
** maybe the default input port should be allowed to be some function that determines what input it gets based on things like whether it's in the background or not?


* a custom exn type for unix pipeline failures?

* Pipeline suspend/resume -- Threads have pause/resume, Unix processes have sigstop/sigcont, but I'm not sure how to pause/suspend windows processes.  Maybe a Unix-only feature?  But this is a pretty standard shell feature for job control.

* bg pipeline disowning?
    Disowning will probably only work for pipelines
    without any racket functions or filters in them.  But perhaps you should
    be able to mark a pipeline as disownable, which would start a new racket
    process which would run the pipeline?  It would have to be very restricted,
    because a pipeline could be using closures, which could not really be copied.
    It looks like bash and zsh can disown a backgrounded shell
    function and have it survive the shell exiting if that function was started
    in the background, which tells me that backgrounded bash/zsh functions are
    run in a subshell.  Presumably this means the process is forked, so that
    the subshell can still access all previously defined functions.  I feel
    like this could have many cases of subtle weirdness, so I'm not sure I
    want to follow that direction without something more explicit marking a
    clear boundary.  Also, fork() only works on Unix, and it would be nice if
    the shell worked on Windows too, so if I can reasonably avoid relying on
    fork, I should.

* initial input-port transformer to try to solve readline-port issues -- there doesn't seem to be any way to get the real stdin port from the readline port, so this is hopeless for the moment.
