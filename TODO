Main stable release blockers
----------------------------

* standardize `run-pipeline` style function interfaces
** in shell/pipeline
*** currently (run-pipeline (spec1) (spec2) ...)
** in mixed-pipeline
*** currently (run-pipeline (list (spec1) (spec2) ...))
** the parenthesised way to run rash code
*** There is currently a version for rash where you have to put the parens around the pipe operator segments, I also want one that is flat and will find the structure based on the operators, for eg. def foo () ls | grep aoeu | wc
*** currently (do-pipeline (=u= ls) (=u= grep foo))

* unix pipeline member argument generalization of env -- run code in thread to change dynamic environment in any way (this makes env easier -- have &env *only* extend/override, and if you want to reset the environment you can use the generalization)

* have lexically scoped defaults for all pipeline options, similar to how the implicit starter operator works

* optional kw-args for rash macros that affect read tables, macros to define rash macros and rash-module-begin with different defaults for all options including read table options

* alternate reader where bare things on the top level are assumed to be normal racket UNLESS there is an explicit start pipe.  This would give an option to have a repl *almost* the same as the default racket repl, except with an easy escape into shell-world.

* object operator that uses aliases as well
** be sure `detect alias` works in new prop:procedure-like way

* I can probably avoid the hash for default-starter by using 3d syntax in the stx-parameterize.  Is that better?


* a version of pipeline running/rash macros that doesn't have all the overhead (maybe one that doesn't allow unix-segments)
** maybe it's not terribly important, because it would be doing mostly the same thing as the threading macro, but it would be more flexible.
** =object-pipe= should have a keyword argument that sets whether it auto-converts ports, and the default is a syntax parameter that the efficient vs convenient rash macros can set accordingly.  Also, this allows the one-off occasions when you do want to do the opposite, without requiring a different =basic-object-pipe=
** obj-pipeline-spec, unix-pipeline-spec, and composite-pipeline-spec should be syntax parameters that are also set by the outside macro to be what they ought to be
** each level of pipeline operator unwrapping should check whether it got another pipeline operator or if it got a spec definition form, which will kill any runtime errors of not getting specs
*** BUT this would mean you couldn't wrap the struct forms, eg. (let ([foo aoeu]) (obj-spec (λ (arg) (foo arg foo)))) -- so is this a good idea?
*** Maybe the efficient version requires no wrapping, but the convenient one allows wrapping.

* maybe pipeline starters used as normal macros should work like (rash «starter-here arg ...»)
** how would this interact with having two different versions - the wrapped convenient backgroundable version vs the non-bg-able non-wrapped version?
*** this definitely would require more firm defaults, because you wouldn't be wrapping it in anything that could set defaults.
*** maybe there are forms to change the defaults (IE syntax-parameterizing) that are available just as s-expressions to wrap these with.
**** Maybe starter-operators have extra properties that say what they want the defaults to be, set by define-pipeline-operator?  Then every starter pipe is also a rash macro... (without a special reader)
*** maybe the fast one is the default, and only certain macros bother with the wrapped way?
** if an explicit pipe were always required, this would just mean than newlines act as parens, but allowing implicit pipes is more like newlines are parens but there is an implicit #%rash-line-macro there.  Plus rash has a modified readtable to provide various conveniences.
*** a potentially useful idea is to have udelim string wrappers whose macro just changes the readtable inside.  This is similar to the option for that that already exists on list delimiters, but string delimiters won't have the issue of maybe not having that same delimiter inside.  You might just have a reader-changing macro that gives you the the rash reader.
**** maybe defaults are set (for wrapped/unwrapped rash, implicit pipe operator, etc) by an implicit #%rash-default-something-or-other macro.  Different rash modules could export different ones.  Problem: if you import two, you have this annoying collision.  This is probably not a good idea.

* make it a syntax error to have a normal racket expression [IE starting a line with an open paren] have a pipeline later on the same line.  This will clear up any issues with having the first segment of a pipeline open with parens.

* review names -- pick good ones before doing any stable release

* add features to shell/pipeline from its todo to get to a stable release point

* document

* look through TODO comments



misc
----

* option-app -- needs better name (kw-check-app?), and should it be part of another package?  I think I want to use it in more packages...


About interactive shells
------------------------

* job control -- for an interactive shell, how should the shell capture references to the pipelines to do job control?

* discoverability
** the default prompt should help with discoverability -- maybe say the command to get help, look up docs, etc.  Something like «type HELP START» in LoE.
** how can interactive features be more discoverable than just being listed in the docs/tutorial?


Documentation
-------------

* API docs
* guide -- high level overview
** maybe split it into sections for people with different backgrounds - eg. racketeers vs people coming from bash who don't know racket.

